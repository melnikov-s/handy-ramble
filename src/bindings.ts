
// This file was generated by [tauri-specta](https://github.com/oscartbeaumont/tauri-specta). Do not edit this file manually.

/** user-defined commands **/


export const commands = {
async changeBinding(id: string, binding: string) : Promise<Result<BindingResponse, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("change_binding", { id, binding }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async resetBinding(id: string) : Promise<Result<BindingResponse, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("reset_binding", { id }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async changePttSetting(enabled: boolean) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("change_ptt_setting", { enabled }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async changeAudioFeedbackSetting(enabled: boolean) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("change_audio_feedback_setting", { enabled }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async changeAudioFeedbackVolumeSetting(volume: number) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("change_audio_feedback_volume_setting", { volume }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async changeSoundThemeSetting(theme: string) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("change_sound_theme_setting", { theme }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async changeStartHiddenSetting(enabled: boolean) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("change_start_hidden_setting", { enabled }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async changeAutostartSetting(enabled: boolean) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("change_autostart_setting", { enabled }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async changeTranslateToEnglishSetting(enabled: boolean) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("change_translate_to_english_setting", { enabled }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async changeSelectedLanguageSetting(language: string) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("change_selected_language_setting", { language }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async changeOverlayPositionSetting(position: string) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("change_overlay_position_setting", { position }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async changeDebugModeSetting(enabled: boolean) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("change_debug_mode_setting", { enabled }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async changeWordCorrectionThresholdSetting(threshold: number) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("change_word_correction_threshold_setting", { threshold }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async changeQuickChatInitialPromptSetting(prompt: string) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("change_quick_chat_initial_prompt_setting", { prompt }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async changePasteMethodSetting(method: string) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("change_paste_method_setting", { method }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async changeClipboardHandlingSetting(handling: string) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("change_clipboard_handling_setting", { handling }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async changePostProcessEnabledSetting(enabled: boolean) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("change_post_process_enabled_setting", { enabled }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async changePostProcessBaseUrlSetting(providerId: string, baseUrl: string) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("change_post_process_base_url_setting", { providerId, baseUrl }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async changePostProcessApiKeySetting(providerId: string, apiKey: string) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("change_post_process_api_key_setting", { providerId, apiKey }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async changePostProcessModelSetting(providerId: string, model: string) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("change_post_process_model_setting", { providerId, model }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async setPostProcessProvider(providerId: string) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("set_post_process_provider", { providerId }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async fetchPostProcessModels(providerId: string) : Promise<Result<string[], string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("fetch_post_process_models", { providerId }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async addPostProcessPrompt(name: string, prompt: string) : Promise<Result<LLMPrompt, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("add_post_process_prompt", { name, prompt }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async updatePostProcessPrompt(id: string, name: string, prompt: string) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("update_post_process_prompt", { id, name, prompt }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async deletePostProcessPrompt(id: string) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("delete_post_process_prompt", { id }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async setPostProcessSelectedPrompt(id: string) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("set_post_process_selected_prompt", { id }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async updateCustomWords(words: string[]) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("update_custom_words", { words }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Temporarily unregister a binding while the user is editing it in the UI.
 * This avoids firing the action while keys are being recorded.
 */
async suspendBinding(id: string) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("suspend_binding", { id }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Re-register the binding after the user has finished editing.
 */
async resumeBinding(id: string) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("resume_binding", { id }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async changeMuteWhileRecordingSetting(enabled: boolean) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("change_mute_while_recording_setting", { enabled }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async changeAppendTrailingSpaceSetting(enabled: boolean) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("change_append_trailing_space_setting", { enabled }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async changeAppLanguageSetting(language: string) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("change_app_language_setting", { language }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async changeRambleEnabledSetting(enabled: boolean) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("change_ramble_enabled_setting", { enabled }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async changeLlmProviderSetting(providerId: string) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("change_llm_provider_setting", { providerId }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async changeRambleProviderSetting(providerId: string) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("change_ramble_provider_setting", { providerId }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async changeRambleModelSetting(model: string) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("change_ramble_model_setting", { model }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async changeRamblePromptSetting(prompt: string) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("change_ramble_prompt_setting", { prompt }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async changeRambleUseVisionModelSetting(enabled: boolean) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("change_ramble_use_vision_model_setting", { enabled }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async changeRambleVisionModelSetting(model: string) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("change_ramble_vision_model_setting", { model }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async resetRamblePromptToDefault() : Promise<Result<string, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("reset_ramble_prompt_to_default") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async changeHoldThresholdSetting(thresholdMs: number) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("change_hold_threshold_setting", { thresholdMs }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async changeClipboardContentCutoffSetting(cutoff: number) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("change_clipboard_content_cutoff_setting", { cutoff }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async changeUpdateChecksSetting(enabled: boolean) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("change_update_checks_setting", { enabled }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async changePromptModeSetting(mode: PromptMode) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("change_prompt_mode_setting", { mode }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async updatePromptCategory(id: string, prompt: string) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("update_prompt_category", { id, prompt }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async resetPromptCategoryToDefault(id: string) : Promise<Result<string, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("reset_prompt_category_to_default", { id }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async changeDefaultCategorySetting(categoryId: string) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("change_default_category_setting", { categoryId }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Create a new custom prompt category
 */
async addPromptCategory(name: string, icon: string, prompt: string) : Promise<Result<PromptCategory, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("add_prompt_category", { name, icon, prompt }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Delete a custom prompt category
 */
async deletePromptCategory(id: string) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("delete_prompt_category", { id }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Update a category's name and icon (not prompt - use update_prompt_category for that)
 */
async updatePromptCategoryDetails(id: string, name: string, icon: string) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("update_prompt_category_details", { id, name, icon }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Update a category's model override (None = use default coherent model)
 */
async updatePromptCategoryModelOverride(id: string, modelId: string | null) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("update_prompt_category_model_override", { id, modelId }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async changeVoiceCommandsEnabledSetting(enabled: boolean) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("change_voice_commands_enabled_setting", { enabled }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async changeVoiceCommandDefaultModelSetting(model: string) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("change_voice_command_default_model_setting", { model }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async resetVoiceCommandsToDefault() : Promise<Result<VoiceCommand[], string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("reset_voice_commands_to_default") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async addVoiceCommand(command: VoiceCommand) : Promise<Result<VoiceCommand[], string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("add_voice_command", { command }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async updateVoiceCommand(command: VoiceCommand) : Promise<Result<VoiceCommand[], string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("update_voice_command", { command }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async deleteVoiceCommand(commandId: string) : Promise<Result<VoiceCommand[], string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("delete_voice_command", { commandId }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async changeFillerWordFilterSetting(pattern: string | null) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("change_filler_word_filter_setting", { pattern }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async changeUnknownCommandTemplateSetting(template: string) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("change_unknown_command_template_setting", { template }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async changeUnknownCommandTerminalSetting(terminal: string) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("change_unknown_command_terminal_setting", { terminal }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async triggerUpdateCheck() : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("trigger_update_check") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async cancelOperation() : Promise<void> {
    await TAURI_INVOKE("cancel_operation");
},
async pauseOperation() : Promise<boolean> {
    return await TAURI_INVOKE("pause_operation");
},
async resumeOperation() : Promise<boolean> {
    return await TAURI_INVOKE("resume_operation");
},
async getAppDirPath() : Promise<Result<string, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_app_dir_path") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async getAppSettings() : Promise<Result<AppSettings, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_app_settings") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async getDefaultSettings() : Promise<Result<AppSettings, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_default_settings") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async getLogDirPath() : Promise<Result<string, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_log_dir_path") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async setLogLevel(level: LogLevel) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("set_log_level", { level }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async openRecordingsFolder() : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("open_recordings_folder") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async openLogDir() : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("open_log_dir") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async openAppDataDir() : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("open_app_data_dir") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async getAvailableModels() : Promise<Result<ModelInfo[], string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_available_models") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async getModelInfo(modelId: string) : Promise<Result<ModelInfo | null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_model_info", { modelId }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async downloadModel(modelId: string) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("download_model", { modelId }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async deleteModel(modelId: string) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("delete_model", { modelId }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async cancelDownload(modelId: string) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("cancel_download", { modelId }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async setActiveModel(modelId: string) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("set_active_model", { modelId }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async getCurrentModel() : Promise<Result<string, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_current_model") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async getTranscriptionModelStatus() : Promise<Result<string | null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_transcription_model_status") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async isModelLoading() : Promise<Result<boolean, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("is_model_loading") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async hasAnyModelsAvailable() : Promise<Result<boolean, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("has_any_models_available") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async hasAnyModelsOrDownloads() : Promise<Result<boolean, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("has_any_models_or_downloads") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async getRecommendedFirstModel() : Promise<Result<string, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_recommended_first_model") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async updateMicrophoneMode(alwaysOn: boolean) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("update_microphone_mode", { alwaysOn }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async getMicrophoneMode() : Promise<Result<boolean, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_microphone_mode") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async getAvailableMicrophones() : Promise<Result<AudioDevice[], string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_available_microphones") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async setSelectedMicrophone(deviceName: string) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("set_selected_microphone", { deviceName }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async getSelectedMicrophone() : Promise<Result<string, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_selected_microphone") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async getAvailableOutputDevices() : Promise<Result<AudioDevice[], string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_available_output_devices") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async setSelectedOutputDevice(deviceName: string) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("set_selected_output_device", { deviceName }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async getSelectedOutputDevice() : Promise<Result<string, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_selected_output_device") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async playTestSound(soundType: string) : Promise<void> {
    await TAURI_INVOKE("play_test_sound", { soundType });
},
async checkCustomSounds() : Promise<CustomSounds> {
    return await TAURI_INVOKE("check_custom_sounds");
},
async setClamshellMicrophone(deviceName: string) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("set_clamshell_microphone", { deviceName }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async getClamshellMicrophone() : Promise<Result<string, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_clamshell_microphone") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async isRecording() : Promise<boolean> {
    return await TAURI_INVOKE("is_recording");
},
async setModelUnloadTimeout(timeout: ModelUnloadTimeout) : Promise<void> {
    await TAURI_INVOKE("set_model_unload_timeout", { timeout });
},
async getModelLoadStatus() : Promise<Result<ModelLoadStatus, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_model_load_status") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async unloadModelManually() : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("unload_model_manually") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async getHistoryEntries() : Promise<Result<HistoryEntry[], string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_history_entries") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async toggleHistoryEntrySaved(id: number) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("toggle_history_entry_saved", { id }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async getAudioFilePath(fileName: string) : Promise<Result<string, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_audio_file_path", { fileName }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async deleteHistoryEntry(id: number) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("delete_history_entry", { id }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async updateHistoryLimit(limit: number) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("update_history_limit", { limit }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async updateRecordingRetentionPeriod(period: string) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("update_recording_retention_period", { period }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Checks if the Mac is a laptop by detecting battery presence
 * 
 * This uses pmset to check for battery information.
 * Returns true if a battery is detected (laptop), false otherwise (desktop)
 */
async isLaptop() : Promise<Result<boolean, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("is_laptop") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Get the list of known applications with suggested categories
 */
async getKnownApplications() : Promise<KnownApp[]> {
    return await TAURI_INVOKE("get_known_applications");
},
/**
 * Get the list of installed applications on the system
 */
async getInstalledApplications() : Promise<InstalledApp[]> {
    return await TAURI_INVOKE("get_installed_applications");
},
/**
 * Get current user-defined app-to-category mappings
 */
async getAppCategoryMappings() : Promise<AppCategoryMapping[]> {
    return await TAURI_INVOKE("get_app_category_mappings");
},
/**
 * Set or update an app-to-category mapping
 */
async setAppCategoryMapping(bundleId: string, displayName: string, categoryId: string) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("set_app_category_mapping", { bundleId, displayName, categoryId }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Remove an app-to-category mapping
 */
async removeAppCategoryMapping(bundleId: string) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("remove_app_category_mapping", { bundleId }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Send a chat completion request to the configured LLM provider
 * 
 * # Arguments
 * * `model_id` - Optional model ID to use. Falls back to `default_chat_model_id` if not provided.
 */
async chatCompletion(messages: ChatMessage[], modelId: string | null, enableGrounding: boolean) : Promise<Result<ChatResponse, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("chat_completion", { messages, modelId, enableGrounding }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Opens a new chat window, optionally with initial context
 */
async openChatWindow(context: string | null) : Promise<Result<string, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("open_chat_window", { context }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Opens a new chat window with initial messages (for forking conversations)
 */
async openChatWindowWithMessages(messages: ForkMessage[]) : Promise<Result<string, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("open_chat_window_with_messages", { messages }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Opens a new chat window loading a saved chat from database
 */
async openSavedChat(chatId: number) : Promise<Result<string, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("open_saved_chat", { chatId }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Command to capture a screenshot or region, hiding all app windows first
 */
async captureScreenMode(region: boolean) : Promise<Result<string, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("capture_screen_mode", { region }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async captureRegionCommand(x: number, y: number, width: number, height: number) : Promise<Result<string, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("capture_region_command", { x, y, width, height }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async openClippingTool() : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("open_clipping_tool") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async restoreAppVisibility() : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("restore_app_visibility") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Retrieves and clears any pending clip attachment
 * Called by ChatWindow to get captured images
 */
async getPendingClip() : Promise<string | null> {
    return await TAURI_INVOKE("get_pending_clip");
},
/**
 * Get all configured LLM providers, deduplicated by ID
 */
async getLlmProviders() : Promise<LLMProvider[]> {
    return await TAURI_INVOKE("get_llm_providers");
},
/**
 * Get all configured LLM models with their provider info, deduplicated by (provider_id, model_id)
 */
async getLlmModels() : Promise<LLMModel[]> {
    return await TAURI_INVOKE("get_llm_models");
},
/**
 * Update an LLM provider's API key
 */
async updateProviderApiKey(providerId: string, apiKey: string) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("update_provider_api_key", { providerId, apiKey }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Save (create or update) an LLM provider
 */
async saveLlmProvider(provider: LLMProvider) : Promise<Result<LLMProvider, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("save_llm_provider", { provider }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Delete an LLM provider (any provider can be deleted)
 */
async deleteLlmProvider(providerId: string) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("delete_llm_provider", { providerId }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Save (create or update) an LLM model
 */
async saveLlmModel(model: LLMModel) : Promise<Result<LLMModel, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("save_llm_model", { model }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Delete an LLM model
 */
async deleteLlmModel(modelId: string) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("delete_llm_model", { modelId }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Set the default model for a specific feature
 */
async setDefaultModel(feature: string, modelId: string | null) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("set_default_model", { feature, modelId }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Get default model IDs for all features
 */
async getDefaultModels() : Promise<DefaultModels> {
    return await TAURI_INVOKE("get_default_models");
},
/**
 * Refresh models for ALL configured providers with API keys
 * Returns the complete updated list of models
 */
async refreshAllModels() : Promise<Result<LLMModel[], string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("refresh_all_models") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async saveChat(title: string | null, messages: ChatMessage[]) : Promise<Result<number, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("save_chat", { title, messages }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async updateChat(id: number, messages: ChatMessage[]) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("update_chat", { id, messages }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async getChat(id: number) : Promise<Result<SavedChat | null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_chat", { id }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async listSavedChats() : Promise<Result<ChatSummary[], string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("list_saved_chats") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async deleteSavedChat(id: number) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("delete_saved_chat", { id }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async generateChatTitle(userMessage: string, assistantResponse: string) : Promise<Result<string, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("generate_chat_title", { userMessage, assistantResponse }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async updateChatTitle(id: number, title: string) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("update_chat_title", { id, title }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async speakText(text: string) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("speak_text", { text }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async stopTts() : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("stop_tts") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
}
}

/** user-defined events **/



/** user-defined constants **/



/** user-defined types **/

/**
 * Maps an application to a category
 */
export type AppCategoryMapping = { bundle_identifier: string; display_name: string; category_id: string }
export type AppSettings = { bindings: Partial<{ [key in string]: ShortcutBinding }>; push_to_talk: boolean; audio_feedback: boolean; audio_feedback_volume?: number; sound_theme?: SoundTheme; start_hidden?: boolean; autostart_enabled?: boolean; update_checks_enabled?: boolean; selected_model?: string; always_on_microphone?: boolean; selected_microphone?: string | null; clamshell_microphone?: string | null; selected_output_device?: string | null; translate_to_english?: boolean; selected_language?: string; overlay_position?: OverlayPosition; debug_mode?: boolean; log_level?: LogLevel; custom_words?: string[]; model_unload_timeout?: ModelUnloadTimeout; word_correction_threshold?: number; history_limit?: number; recording_retention_period?: RecordingRetentionPeriod; 
/**
 * All configured LLM providers (OpenAI, Anthropic, OpenRouter, custom)
 */
llm_providers?: LLMProvider[]; 
/**
 * All configured models across all providers
 */
llm_models?: LLMModel[]; 
/**
 * Default model ID for chat windows
 */
default_chat_model_id?: string | null; 
/**
 * Default model ID for coherent/ramble mode
 */
default_coherent_model_id?: string | null; 
/**
 * Default model ID for voice commands
 */
default_voice_model_id?: string | null; paste_method?: PasteMethod; clipboard_handling?: ClipboardHandling; 
/**
 * Prompts for coherent mode (transforms rambling speech to clean text)
 */
coherent_prompts?: LLMPrompt[]; coherent_selected_prompt_id?: string | null; mute_while_recording?: boolean; append_trailing_space?: boolean; app_language?: string; 
/**
 * Whether coherent mode (LLM refinement) is enabled
 */
coherent_enabled?: boolean; 
/**
 * Whether to use vision model when screenshots are available
 */
coherent_use_vision?: boolean; 
/**
 * Threshold in milliseconds for tap vs hold detection (smart PTT)
 */
hold_threshold_ms?: number; 
/**
 * Current prompt mode (Dynamic, Low, Medium, High)
 */
prompt_mode?: PromptMode; 
/**
 * Prompt categories (built-in + user-defined)
 */
prompt_categories?: PromptCategory[]; 
/**
 * Application to category mappings
 */
app_category_mappings?: AppCategoryMapping[]; 
/**
 * History of detected applications (for dropdown suggestions)
 */
detected_apps_history?: DetectedApp[]; 
/**
 * Default category for apps not in known_apps or user mappings
 */
default_category_id?: string; 
/**
 * Whether voice commands are enabled
 */
voice_commands_enabled?: boolean; 
/**
 * Default model for voice command execution
 */
voice_command_default_model?: string; 
/**
 * User-defined voice commands
 */
voice_commands?: VoiceCommand[]; tts_enabled?: boolean; tts_selected_model?: string | null; tts_speed?: number; tts_volume?: number; filler_word_filter?: string | null; 
/**
 * Customizable initial prompt for the quick chat
 */
quick_chat_initial_prompt?: string; 
/**
 * Whether to launch CLI agent for unknown commands (instead of showing error)
 */
unknown_command_agent_enabled?: boolean; 
/**
 * Template for the CLI command to run. Supports ${prompt} placeholder.
 * Example: `claude -p "${prompt}"` or `gemini "${prompt}"`
 */
unknown_command_template?: string; 
/**
 * Terminal application to use (iTerm, Terminal, Warp)
 */
unknown_command_terminal?: string; 
/**
 * Maximum characters to include from clipboard content in ${clipboard} variable
 * 0 = no cutoff (include all), other values = limit to N characters
 */
clipboard_content_cutoff?: number }
export type AudioDevice = { index: string; name: string; is_default: boolean }
export type BindingResponse = { success: boolean; binding: ShortcutBinding | null; error: string | null }
export type ChatMessage = { role: string; content: string; images: string[] | null }
export type ChatResponse = { content: string; grounding_metadata: GroundingMetadata | null }
export type ChatSummary = { id: number; title: string; created_at: number; updated_at: number; message_count: number }
export type ClipboardHandling = "dont_modify" | "copy_to_clipboard"
export type CustomSounds = { start: boolean; stop: boolean }
export type DefaultModels = { chat: string | null; coherent: string | null; voice: string | null }
/**
 * Detected app info (for tracking history)
 */
export type DetectedApp = { bundle_identifier: string; display_name: string; last_seen: number }
export type EngineType = "Whisper" | "Parakeet" | "TTS"
/**
 * Message structure for forking conversations
 */
export type ForkMessage = { role: string; content: string }
export type GroundingChunk = { uri: string | null; title: string | null }
export type GroundingMetadata = { search_entry_point: string | null; chunks: GroundingChunk[] }
export type HistoryEntry = { id: number; file_name: string; timestamp: number; saved: boolean; title: string; transcription_text: string; post_processed_text: string | null; post_process_prompt: string | null; transcription_status: string; transcription_error: string | null }
/**
 * Information about an installed application (from JSON)
 */
export type InstalledApp = { bundle_id: string; name: string }
/**
 * A known application with suggested category
 */
export type KnownApp = { bundle_id: string; name: string; suggested_category: string }
/**
 * Model configuration for a specific provider
 */
export type LLMModel = { 
/**
 * Unique identifier (UUID string)
 */
id: string; 
/**
 * Provider ID this model belongs to
 */
provider_id: string; 
/**
 * Model identifier sent to API (e.g., "gpt-4o", "anthropic/claude-3-opus")
 */
model_id: string; 
/**
 * User-friendly display name
 */
display_name: string; 
/**
 * Whether this model supports vision/image inputs
 */
supports_vision?: boolean; 
/**
 * Whether this model is enabled and should appear in model selectors
 */
enabled?: boolean }
export type LLMPrompt = { id: string; name: string; prompt: string }
/**
 * Unified LLM provider configuration
 * Supports OpenAI, Anthropic, Gemini, OpenRouter, and custom enterprise proxies
 */
export type LLMProvider = { 
/**
 * Unique identifier (UUID string)
 */
id: string; 
/**
 * Display name (e.g., "OpenAI", "OpenRouter", "My Proxy")
 */
name: string; 
/**
 * API base URL (editable for custom endpoints)
 */
base_url: string; 
/**
 * User's API key for this provider
 */
api_key?: string; 
/**
 * Whether this provider supports vision/image inputs
 */
supports_vision?: boolean; 
/**
 * Whether this is a user-added custom provider vs preset
 */
is_custom?: boolean }
export type LogLevel = "trace" | "debug" | "info" | "warn" | "error"
export type ModelInfo = { id: string; name: string; description: string; filename: string; url: string | null; size_mb: number; is_downloaded: boolean; is_downloading: boolean; partial_size: number; is_directory: boolean; engine_type: EngineType; accuracy_score: number; speed_score: number }
export type ModelLoadStatus = { is_loaded: boolean; current_model: string | null }
export type ModelUnloadTimeout = "never" | "immediately" | "min_2" | "min_5" | "min_10" | "min_15" | "hour_1" | "sec_5"
export type OverlayPosition = "none" | "top" | "bottom"
export type PasteMethod = "ctrl_v" | "direct" | "none" | "shift_insert" | "ctrl_shift_v"
/**
 * A prompt category that groups applications and defines processing style
 */
export type PromptCategory = { id: string; name: string; icon: string; prompt: string; is_builtin: boolean; 
/**
 * Optional model override for this category (None = use default coherent model)
 */
model_override?: string | null }
/**
 * Prompt mode selection - Dynamic auto-detects based on app, others are explicit processing levels
 */
export type PromptMode = "dynamic" | 
/**
 * Low processing: minimal intervention, just grammar and filler removal
 */
"low" | 
/**
 * Medium processing: standard polish, formatting, and structure
 */
"medium" | 
/**
 * High processing: intent extraction, aggressive restructuring
 */
"high"
export type RecordingRetentionPeriod = "never" | "preserve_limit" | "days_3" | "weeks_2" | "months_3"
export type SavedChat = { id: number; title: string; created_at: number; updated_at: number; messages: ChatMessage[] }
/**
 * Script type for bespoke commands
 */
export type ScriptType = "shell" | "apple_script"
export type ShortcutBinding = { id: string; name: string; description: string; default_binding: string; current_binding: string }
export type SoundTheme = "marimba" | "pop" | "custom"
/**
 * A voice command definition
 */
export type VoiceCommand = { 
/**
 * Unique identifier for the command
 */
id: string; 
/**
 * Human-readable name
 */
name: string; 
/**
 * Trigger phrases that activate this command
 */
phrases: string[]; 
/**
 * Type of command (inferable or bespoke)
 */
command_type: VoiceCommandType; 
/**
 * Description for LLM (inferable commands)
 */
description?: string | null; 
/**
 * Script type (bespoke commands)
 */
script_type?: ScriptType; 
/**
 * Script content (bespoke commands)
 */
script?: string | null; 
/**
 * Model override (uses default if None)
 */
model_override?: string | null; 
/**
 * Whether this is a built-in command
 */
is_builtin?: boolean }
/**
 * Type of voice command
 */
export type VoiceCommandType = 
/**
 * Built-in command with native handler (web_search, open_app, print, etc.)
 */
"builtin" | 
/**
 * User-defined script (shell or AppleScript)
 */
"custom"

/** tauri-specta globals **/

import {
	invoke as TAURI_INVOKE,
	Channel as TAURI_CHANNEL,
} from "@tauri-apps/api/core";
import * as TAURI_API_EVENT from "@tauri-apps/api/event";
import { type WebviewWindow as __WebviewWindow__ } from "@tauri-apps/api/webviewWindow";

type __EventObj__<T> = {
	listen: (
		cb: TAURI_API_EVENT.EventCallback<T>,
	) => ReturnType<typeof TAURI_API_EVENT.listen<T>>;
	once: (
		cb: TAURI_API_EVENT.EventCallback<T>,
	) => ReturnType<typeof TAURI_API_EVENT.once<T>>;
	emit: null extends T
		? (payload?: T) => ReturnType<typeof TAURI_API_EVENT.emit>
		: (payload: T) => ReturnType<typeof TAURI_API_EVENT.emit>;
};

export type Result<T, E> =
	| { status: "ok"; data: T }
	| { status: "error"; error: E };

function __makeEvents__<T extends Record<string, any>>(
	mappings: Record<keyof T, string>,
) {
	return new Proxy(
		{} as unknown as {
			[K in keyof T]: __EventObj__<T[K]> & {
				(handle: __WebviewWindow__): __EventObj__<T[K]>;
			};
		},
		{
			get: (_, event) => {
				const name = mappings[event as keyof T];

				return new Proxy((() => {}) as any, {
					apply: (_, __, [window]: [__WebviewWindow__]) => ({
						listen: (arg: any) => window.listen(name, arg),
						once: (arg: any) => window.once(name, arg),
						emit: (arg: any) => window.emit(name, arg),
					}),
					get: (_, command: keyof __EventObj__<any>) => {
						switch (command) {
							case "listen":
								return (arg: any) => TAURI_API_EVENT.listen(name, arg);
							case "once":
								return (arg: any) => TAURI_API_EVENT.once(name, arg);
							case "emit":
								return (arg: any) => TAURI_API_EVENT.emit(name, arg);
						}
					},
				});
			},
		},
	);
}
